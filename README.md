# lesson28
1.  Для сложения двух положительных целых чисел, записанных в 8-разрядные ячейки, нужно сложить соответствующие разряды столбиком, начиная с младшего разряда. Если в полученной сумме есть разряд, который больше 1, то в текущий разряд результата записывается последняя цифра этой суммы, а в следующий разряд переносится 1.Если числа будут отрицательными, то мы должны использовать представление чисел в дополнительном коде. Чтобы представить число в дополнительном коде, сперва представляем его в бинарном виде, потом инвертируем каждый бит и прибавляем 1. Затем складываем два отрицательных числа так же, как и положительные. При этом, если полученный результат в 8-разрядной ячейке имеет значение 1 в самом старшем разряде, это означает, что произошло переполнение.

2. система представления знаковых целых, упрощающая выполнение двоичной арифметики
3. либо наличие переноса из знакового разряда суммы при отсутствии переноса в этом разряде
4. Арифметико-логическое устройство (ALU) выполняет над данными основные арифметические (сложение, вычитание, умножение и деление) и логические операции (AND, OR и NOT).
5. Специального устройства для вычитания целых чисел не требуется, поскольку операция вычитания выполняется путем выполнения сложения в дополнительном коде.
6. Чтобы перемножить два положительных целых числа в двоичной системе счисления, мы используем алгоритм умножения столбиком. Изменение знака одного из сомножителей не влияет на алгоритм выполнения операции умножения.
7. Коды чисел со знаком и без знака нужно сравнивать по-разному, потому что представление чисел со знаком включает в себя дополнительный разряд, представляющий знак числа. При сравнении кодов чисел со знаком, мы должны учитывать их знаки, чтобы определить, какое число больше.
8. Поразрядные операции — это операции, которые выполняются непосредственно над отдельными битами (разрядами) чисел. Такие операции часто используются в программировании для работы с двоичными числами, управления битами, а также для оптимизации производительности
9. Арифметические операции нельзя отнести к поразрядным, потому что при выполнении арифметических операций нужно учитывать не только значения отдельных битов, но и их позиции в числе.
10. Маска — это последовательность букв, цифр и других допустимых в именах файлов символов
11. Создайте маску с 1 в нужных позициях. Для тех же позиций исходного числа, которые должны остаться 1, в маске нужно также указать 1.
12. Для того чтобы сбросить 2 младших бита в 16-разрядном числе, не изменяя все остальные, нужно использовать маску со значением 0xFFFC. Для этого мы инвертируем биты, которые нужно сбросить, и применяем операцию "И" с исходным числом.
13. Чтобы установить определённый бит (то есть записать в него 1) с использованием битовой маски, необходимо создать маску, в которой целевой бит будет равен 1, а все остальные биты — равны 0
14. Чтобы установить 2 старших бита 16-разрядного числа, нужно создать маску, в которой 2 старших бита равны 1, а все остальные 14 битов равны 0
15. Для определения, делится ли число на 4 или на 8, можно использовать логические операции. Если число делится на 4, то его младшие два бита должны быть равны 0. Если число делится на 8, то младшие три бита должны быть равны 0.
16. Установка или сброс битов двоичного кода может быть использована, например, в задачах контроля доступа, кодирования информации, определения состояния устройств, изменения настроек и т.д.
17. Операция "исключающее ИЛИ" имеет следующие возможности:
- Если оба бита равны 0 или равны 1, результат будет 0.
- Если один из битов равен 1, а другой равен 0, результат будет 1.
18. Алгоритм шифрования кода с использованием операции "исключающее ИЛИ" может быть следующим:
- Используем случайно генерируемую ключевую маску с таким же размером, как и исходное сообщение.
- Применяем операцию "исключающее ИЛИ" между ключевой маской и исходным сообщением.
- Полученный результат будет зашифрованным кодом сообщения.
- Для расшифровки нужно применить операцию "исключающее ИЛИ" между зашифрованным кодом и ключевой маской.
19. Для определения совпадают или нет биты S' и S при выполнении сложения, можно использовать операцию "исключающее ИЛИ" между этими битами. Если результат будет равен 0, значит биты совпадают, иначе они не совпадают.
20. Операция "НЕ" играет роль при получении отрицательных чисел в представлении в дополнительном коде. Применение операции "НЕ" к числу инвертирует каждый бит числа.
21. Для инверсии всех битов без использования логической операции «НЕ» можно применить побитовое отрицание (оператор ~).
22. Битовый сдвиг это изменение позиций бит в машинном слове.Логический,арифметический и циклический
23. При различных типах сдвига самый старший и самый младший биты могут обрабатываться по-разному. Например, при арифметическом сдвиге вправо самый старший бит сохраняется, при логическом сдвиге вправо - самый старший бит заполняется нулем, а при циклическом сдвиге вправо - самый старший бит становится младшим.
24. Сдвиг влево двоичного кода удваивает число, потому что при каждом сдвиге влево каждый разряд умножается на 2. Сдвиг вправо уменьшает число вдвое, потому что при каждом сдвиге вправо каждый разряд делится на 2.
25. Логический сдвиг не годится для уменьшения в два раза отрицательных чисел, потому что он не сохраняет знак числа. Арифметический сдвиг, в отличие от логического, сохраняет знак числа. При арифметическом сдвиге вправо отрицательные числа уменьшаются вдвое, а при сдвиге влево увеличиваются вдвое.
26. Арифметический сдвиг влево, в отличие от арифметического сдвига вправо, в общем случае не имеет отдельного определения, так как его поведение аналогично логическому сдвигу влево
27. Правило вычисления результата арифметического сдвига отрицательного нечётного числа на один разряд вправо следующее:
- Каждый разряд числа сдвигается на один разряд вправо.
- Самый старший разряд заполняется единицей, если знак числа отрицательный, иначе нулем.
- Знак числа остается неизменным.
Это правило применимо и к положительным нечетным числам.
Формула упрощается для четных исходных значений, так как после арифметического сдвига четного числа на один разряд вправо, результат будет равен половине исходного числа.
28. Применяется в языках программирования и цифровой технике
# Задачи
1. 00011111 + 00010011 = 00110010
2. 11100001 + 00010011 = 11110100
3. 
4. 1011111 ; 11011111
5. 1100 * 111 = 1010100
6. 11110100 * 111 = 10101100-
7. Коля просто догодался пременить переместительный закон для умножения
8. 119 и 136 , 119 и -120
9. код заглавиой = код строчной abdF16
10. код cтрочной = код загалавной or2016
11. Решение коли приводит к неправильным ответам , когда сумма цифр больше 15
12.  4 , 8 , 16 - все они деляться на число 4
13. X and 1=0 , X and 7=0 , X and F = 0
14. a: = a xor b ; b:= b xor a ; a:= a xor b
15.  R: = x Shr 16 ; 6: = ( X Sbr 8 ) 8 F16 ; B: = x
16. правильны оба
17. y : = ( X Shi4 ) Shr4 ; z:= ( X Shr4 ) Shi4
18. при использовании 16 - битных данных : EDCO16 , EDF16
19. при использовании 16 - битных данных : 0123(16) 4123(16) 0123(16) OFED(16) CFED(16) FFED(16)
20. EE(16) ; 77(16) = 119 = ( 256 - 18 ) 12 , F7(16) = -9
21. FF(16) , FF(16) , FF(16) ,
22. Z = 1100(2) = 12

    Z = Z ShI 1 = 11000(2)

    X = Z = 11000(2)

    X = X ShI 2 = 1100000(2)



    X = X + Z = 1111000(2) = 120
